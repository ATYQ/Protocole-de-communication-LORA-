L'objetif principale de mon projet est de construire un accélérométre à base de la technologie MEMS et a déployé dans un milieu urbain et qu'il puisse communiquer ses données à l'ensemble de batiment 


programme C



#include "stm32l1xx.h"
#include "stm32l1xx_nucleo.h"
#include <stdio.h>
uint16_t adc_data_PC0,adc_data_PC1,adc_data_PC2;
GPIO_InitTypeDef GPIO_InitStructure;
ADC_InitTypeDef ADC_InitStructure;
ADC_CommonInitTypeDef ADC_CommonInitStructure;
void confgADC()
{
RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE); // ADC
RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOC, ENABLE); // X OUT les pc-2
channel 12
// pour la sortie xout
 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2;
 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 GPIO_Init(GPIOC, &GPIO_InitStructure);
 // onfig adc and initialize ADC
 ADC_Init(ADC1, &ADC_InitStructure);
 ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
 ADC_InitStructure.ADC_ScanConvMode=ENABLE;
 ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
 ADC_InitStructure.ADC_ExternalTrigConvEdge =
ADC_ExternalTrigConvEdge_None;

ADC_InitStructure.ADC_ExternalTrigConv=ADC_ExternalTrigConv_T2_CC2;
 ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
3
 ADC_InitStructure.ADC_NbrOfConversion = 2;
 ADC_CommonInitStructure.ADC_Prescaler=ADC_Prescaler_Div2;
 ADC_CommonInit(&ADC_CommonInitStructure);
}
void Usart2Init ()
{
GPIO_InitTypeDef GPIO_Init_USART;
USART_InitTypeDef USART_InitStructure;
RCC_AHBPeriphClockCmd (RCC_AHBPeriph_GPIOA , ENABLE);
GPIO_Init_USART.GPIO_Pin = GPIO_Pin_2;
GPIO_Init_USART.GPIO_Mode = GPIO_Mode_AF;
GPIO_Init_USART.GPIO_Speed = GPIO_Speed_40MHz;
GPIO_Init_USART.GPIO_OType= GPIO_OType_PP;
GPIO_Init_USART.GPIO_PuPd=GPIO_PuPd_UP;
 GPIO_Init (GPIOA,& GPIO_Init_USART);
 GPIO_Init_USART.GPIO_Pin = GPIO_Pin_3;
 GPIO_Init_USART.GPIO_Mode = GPIO_Mode_IN;
 GPIO_Init (GPIOA,& GPIO_Init_USART);
 GPIO_PinAFConfig(GPIOA ,GPIO_PinSource2 ,GPIO_AF_USART2);
 GPIO_PinAFConfig(GPIOA ,GPIO_PinSource3 ,GPIO_AF_USART2);
 RCC_APB1PeriphClockCmd (RCC_APB1Periph_USART2, ENABLE);
 USART_InitStructure.USART_BaudRate = 9600;
 USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 USART_InitStructure.USART_StopBits = USART_StopBits_1;
 USART_InitStructure.USART_Parity = USART_Parity_No;
 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 USART_InitStructure.USART_HardwareFlowControl =
USART_HardwareFlowControl_None;
 USART_Init (USART2,& USART_InitStructure);
 USART_Cmd (USART2, ENABLE);
}
uint16_t RedXADC()
{
ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1, ADC_SampleTime_16Cycles);
ADC_Cmd(ADC1, ENABLE);
while(ADC_GetFlagStatus(ADC1, ADC_FLAG_ADONS) == RESET)
 {}
 ADC_SoftwareStartConv(ADC1);
 adc_data_PC0= ADC_GetConversionValue(ADC1);
 return adc_data_PC0;
}
uint16_t RedYADC()
{
ADC_RegularChannelConfig(ADC1, ADC_Channel_11, 1, ADC_SampleTime_16Cycles);
ADC_Cmd(ADC1, ENABLE);
while(ADC_GetFlagStatus(ADC1, ADC_FLAG_ADONS) == RESET)
 {}
 ADC_SoftwareStartConv(ADC1);
 adc_data_PC1= ADC_GetConversionValue(ADC1);
 return adc_data_PC1;
}
uint16_t RedZADC()
{
ADC_RegularChannelConfig(ADC1, ADC_Channel_12, 1, ADC_SampleTime_16Cycles);
ADC_Cmd(ADC1, ENABLE);
while(ADC_GetFlagStatus(ADC1, ADC_FLAG_ADONS) == RESET)
4
 {}
 ADC_SoftwareStartConv(ADC1);
 adc_data_PC2= ADC_GetConversionValue(ADC1);
 return adc_data_PC2;
}
void send_char(char x)
{
 while(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET);
 USART_SendData(USART2,x);
}
void send_str(char* str)
{
 int x=0;
 while(str[x])
 send_char(str[x++]);
}
void delay(int x)
{
for(int i=0;i<1000*x;i++)
{}
}
void send_nbr(int nbr)
{
 if(nbr/10)
 send_nbr(nbr/10);
 send_char((nbr%10)+48);
}
int main(void)
{
 uint16_t Vx;
 float Resultatvalue;
confgADC();
Usart2Init ();
while(1)
{
 Vx=RedXADC();
 Resultatvalue=(float)(Vx*3.6)/4095;
 send_nbr((float)Resultatvalue);
 delay(10000);
 send_char('\n');
}
}
Conclusion
Dans cette partie j’ai 
